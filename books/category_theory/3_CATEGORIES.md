# Chapter 3. Categories Great and Small

## 3.1 No Objects

- Most trivial
- because no objects, no morphisms
  - if an empty set makes sense, why not an empty category

## 3.2 Simple Graphs

You can imagine starting with any directed graph, and making it into a category by simply adding more arrows.

- first, add an identity arrow at each node
- then, for any two arrows such that the end of one coincides with the beginning of the other (aka any two *composable* arrows), add a new arrow to serve as their composition
- every time you add a new arrow, you have to also consider its composition with any other arrow (except for the id arrow)

Another way, is that youre creating a category, which has an object for every node in the graph, and all possible chains of composable graph edges as morphisms. (You may even consider id morphisms as special cases of chains of length zero)

- such a category is called a *free category* generated by a given graph.
- Free construction, the proces sof completing a given structure by extending it with a minimum number of items to satisfy its laws

## 3.3 Orders

A category where a morphism is a relation between objects: the relation of being less than or equal

- preorder
  - a <= b and b <= c, so a <= c
  - type of category where there is at most one morphism
  - thin category
- partial order
  - a <= b, and b <= a, so a == b
- linear order aka total order
  - condition that any two objects are in a relation with each other, one way or another

A set of morphism from object a to object b in category C is called a *hom-set* written as C(a, b) or, Hom_C(a, b)

- Every hom-set in a preorder is either empty or a singleton
  - Includes hom-set C(a, a)
    - the set of morphisms from a to a, which must be a singleton, the id, in any preorder
  - you may have cycles in a preorder
  - cycles are forbidden in a partial order

Important to recognize these for sorting:

- Sorting algorithms, quicksort, bubble, merge, can only work on total orders
- Partial orders can be sorted using topological sort

## 3.4 Monoid as Set

- Addition and multiplication for a monoid
- Ubiquitous in programming

Traditionally, a monoid is defined as a set with binary operations

- All thats required from this operation is that it is associative
- and there is one special element that behaves like a unit with respect to it

Neutral elements:

- in addition, neutral element is 0
  - 0+a = a
  - a+0 = a
- in string concat
  - not commutative, but still a monoid
  - neutral element is an empty string
    - can be put at front or the end

```hs
class Monoid m where
  mempty :: m -- the neutral element
  mappend :: m -> m -> m -- the binary operation
```

Its up to the programmer to ensure the neutral element and associativity, this is not built into HS

```hs
-- defining a string
instance Monoid String where
  mempty = ""
  mappend = (++)
  -- note (++) is the list concat operator (bc string is list of char)
```

Note: any infix operator can be turned into a two argument function by surrounding it with parenthesses:

- "Hello " ++ "world!"
- (++) "Hello " "world!"
  - In the latter, the function is ++, and hello and world become arguments

Note that args to a fn are not separated by commas or surrounded by parentheses (this is probably the hardest thing to get used to when learning Haskell)

Can express equality of functions as in:

```hs
-- equality of morphisms in the category Hask or Set
-- these are succinct, and can often be generalized to other categories
mappend = (++)

-- which is different than expressing the equality of values
-- produced by functions, as in
-- extensional equality: states the fact that for any two input
-- strings, the outputs of mappend and (++) are the same
-- since the values of arguments are sometimes called *points*
-- (as in: the value of f at point x)
-- this is called point-wise equality
-- Function equality without specifying the arguments is
-- described as *point-free*
mappend s1 s2 = (++) s1 s2
```

Incidentally, point-free equations often involve composition of functions, which is symbolized by a point, so this might be a little confusing to the beginner

## 3.5 Monoid as Category

In category theory, we try to get away from sets and their elements, and instead talk about objects and morphisms. Lets change perspective, and think of:

- the application of the binary operator as:
  - "moving" or "shifting" things around the set

A function that adds 5, is a function that adds n. If we compose a function that adds 5 with a function that adds 12, we get a function that adds 12. The composition of adders is equivalent to the rules of addition. So, we can replace addition with function composition.

The adder for the neutral element, zero doesnt do antyhing (x + 0) = x, so its the identity function (in the set of natural numbers)

- m -> (m -> m)
  - tells us that mappend maps an element of a monoid set to a function acting on that set

Forget the set of natural numbers and think of it as a single object, a blob with a bunch of morphisms - the adders. A monoid is a single object category. In fact, the name monoid comes from Greek mono, which means single. Every monoid can be described as a single object category with a set of morphisms that follow appropriate rules of composition

String concat is an interesting case b/c prepeding or appending. The composition tables of the two models are mirror reverse of each other. Can easily convince yourself that appending bar after foo correspondds to prepeding foo after prepending bar

One might ask:

- is every categorical monoid
  - a one-object category
- defines a unique set-with-binary-operator monoid?
- We can always extract a set from a single-object category
  - this set is the set of morphisms
    - aka the adders in our example
- Aka:
  - we have the hom-set M(m,m) of a single object m in the category M
  - we easily define a binary operator in this set:
    - the monoidal product of two set-elements is the element corresponding to the composition of the corresponding morphisms
    - if you give me two elements of M(m,m) corresponding to f and g, their product will correspond to the composition f.g
    - the composition always exists, because the source and the target for these morphisms are the same object.
    - and its associative by the rules of category
    - the the identity morphism is the neutral element of this product
    - so we can always recover a set monoid from a category monoid
    - for all intents and purposes, they are one and the same

Note: Morphisms dont ahve to form a set. In the world of categories, there are things larger than sets. A category in which morphisms between any two objects form a set is called **locally small**

A lot of interesting phenomena in category theory have their root in the fact that elements of a hom-set can be seen both as morphisms, which follow the rules of composition, and as points in a set. Here, compositions of morphisms in M translates into monoidal product in the set M(m,m)

### Questions

- difference between:
  - set monoid
  - category monoid
